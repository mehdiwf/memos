* General rqs
Code is more read than it is written
[[https://www.python.org/dev/peps/pep-0008/][PEP8 recommandations]]

Structuring your project
[[https://docs.python-guide.org/writing/structure/][Python guide to structure a project]]
* Commented code snippets
** Before everything
#+begin_src python :results output
#!/usr/bin/env python3
# coding: utf-8

# librairy importation ...
# Function and/or class definition...

if __name__ == '__main__':

    stuff

#+end_src
** General
*** Version of modules/packages
#+begin_src python :results output
import numpy as np
print(np.__version__)
#+end_src

#+RESULTS:
: 1.21.4

*** Files
**** Listing files
***** All files
You can list all the files in a directory and all the files in the
subdirectories

#+begin_src python :results output
directory = ...
data = [os.path.join(dp, f) for dp, dn, fn in os.walk(os.path.expanduser(directory)) for f in fn]
#+end_src

***** Selecting all files with an extension

#+begin_src python :results output
# selecting all pdf files
files_list = [y for x in os.walk(directory) for y in glob(os.path.join(x[0], '*.pdf'))]
#+end_src

**** importing/loading .py files
***** Same directory

 [[https://www.freecodecamp.org/news/if-name-main-python-example/][How to import .py files and why __main__]]

 let's say that your file script.py is in a directory ./ 
 you also have data.py with a variable in it, defined with
 =a=2=
 you can:

 #+begin_src python :results output
 import data # or import data as d
 # or (but I didn't test it yet)
 # https://docs.python.org/3/library/importlib.html#importlib.import_module
 from importlib import import_module as import_mod
 module = 'data'
 import_mod(module)

 # returns true if data has a variable called b
 print(hasattr(data, 'b')) 

 # print the variable
 print(data.a)

 # Or if you don't know what will be the names of the things you're
 # importing: dir(data) can tell you, if you filter it
 imported_variables = [item for item in dir(data) if not item.startswith("__")]

 for e in imported_variables:
     #getattr gets the value of the variable e (e is a string)
     print(getattr(data, e))
 #you can also:
 getattr(data, 'a')
 #+end_src
***** Other directory
from [[https://stackoverflow.com/questions/22955684/how-to-import-py-file-from-another-directory][stack overflow question]]
#+begin_src python :results output
import sys
sys.path.insert(0, 'path/to/your/py_file')

import py_file
#+end_src
**** Opening
***** open safely
To open a file safely:
#+begin_src python :results output
with open("file.txt","r") as fichier:
    make some stuff
#+end_src
you ran replace the "r" with:
***** options
****** r reading
The file pointer is placed at the beginning of the file. This is the
default mode.
****** r+ both reading and writing
The file pointer will be at the beginning of the file.
****** w writing only
Overwrites the file if the file exists. If the file does not exist,
creates a new file for writing.
****** w+ both writing and reading
Opens a file for both . Overwrites the existing file if the file
exists. If the file does not exist, it creates a new file for reading
and writing.
****** rb reading only in binary format
The file pointer is placed at the beginning of the file.
****** rb+ both reading and writing in binary format
****** wb+ both writing and reading in binary format
Opens a file for . Overwrites the existing file if the file exists. If
the file does not exist, it creates a new file for reading and
writing.
****** a appending
Opens a file for appending. The file pointer is at the end of the file
if the file exists. That is, the file is in the append mode. If the
file does not exist, it creates a new file for writing.
****** ab appending in binary format
The file pointer is at the end of the file if the file exists. That
is, the file is in the append mode. If the file does not exist, it
creates a new file for writing.
****** a+ both appending and reading
The file pointer is at the end of the file if the file exists. The
file opens in the append mode. If the file does not exist, it creates
a new file for reading and writing.
****** ab+ both appending and reading in binary format
The file pointer is at the end of the file if the file exists. The
file opens in the append mode. If the file does not exist, it creates
a new file for reading and writing.
****** x exclusive creation
failing if the file already exists
  (Python 3)
***** skipping rows/# commentaries
#+begin_src python :results output
extracted_data = np.loadtxt(lines, delimiter=delim, skiprows=1)
# and also to skip #:
with open(csv_file_name) as f:
    lines = (line for line in f if not line.startswith('#'))
    data = np.genfromtxt(lines, delimiter=',', dtype='object')
#+end_src
**** Modify the file
to write:
#+begin_src python :results output
fichier.write('yikers')
#+end_src

**** Getting the size of files in a directory
https://stackoverflow.com/questions/1392413/calculating-a-directorys-size-using-python

#+begin_src python :results output
import os
sum(os.path.getsize(f) for f in os.listdir(directory) if os.path.isfile(f))
#+end_src

**** exporting data
***** TODO rewrite this less particular
#+begin_src python :results output
import numpy as np

csv_file_name = 'donnees_formatees.csv'    

with open(csv_file_name) as f:
    lines = (line for line in f if not line.startswith('#'))
    data = np.genfromtxt(lines, delimiter=',', dtype='object')

def create_csv_file(material_list, csv_name_file):    
    nb_material = len(material_list)
    #nb is nb_material
    young_table = np.zeros((nb_material + 1, 3), dtype='object')
    poisson_table = np.zeros((nb_material + 1, 3), dtype='object')
    young_table[0,0] = ' '
    poisson_table[0,0] = ' '
    young_table[0,1], young_table[0,2] = 'Module de Young', 'Intervalle de confiance (95%)'
    poisson_table[0,1], poisson_table[0,2] = 'Coefficient de Poisson', 'Intervalle de confiance (95%)'

    for i in range(nb_material):
        name_ref = material_list[i][0]
        name = material_list[i][1]

        i_table = i+1
        young_table[i_table,0] = name
        poisson_table[i_table,0] = name
        indice = np.where(data==name_ref)[0][0]

        young_table[i_table, 1], young_table[i_table, 2] = float(data[indice, 1]), float(data[indice, 2])
        poisson_table[i_table, 1], poisson_table[i_table, 2] = float(data[indice, 3]), float(data[indice, 4])
    np.savetxt('{}_poisson.csv'.format(csv_name_file), poisson_table, delimiter = ',', fmt='%s')
    np.savetxt('{}_young.csv'.format(csv_name_file), young_table, delimiter = ',', fmt='%s')

names = np.array(data[:,0], dtype='str')
numbers = np.array(data[:,1:5], dtype='float')

metals_list = [[b'acier_polie',
                'acier 304-L'],
               [b'aluminium_AG5',
                'aluminium AG5'],
               [b'aluminium_AUG4',
                'aluminium AUG4'],
               [b'cuivre',
                'cuivre'],
               [b'laiton',
                'laiton'],
               [b'nickel',
                'nickel'],
               [b'titane',
                'titane T6AV'],
               [b'tantale',
                'tantale'],
               [b'molybdene',
                'molybdène'],
               [b'fonte',
                'fonte']]

crystals_list = [[b'ZrO2',
                  'ZrO2'],
                 [b'LiNbO3_face_',
                  'LiNbO3'],
                 [b'LGT',
                  'LGT']]

acier_surfaces_list = [[b'acier_polie',
                        'face polie'],
                       [b'acier_ecrouie',
                        'face écrouie'],
                       [b'acier_striee_para',
                        'face striée parallèle'],
                       [b'acier_striee_perp',
                        'face striée perpandiculaire']]

create_csv_file(metals_list,'metals_csv')
create_csv_file(crystals_list,'crystals_csv')
create_csv_file(acier_surfaces_list,'acier_surfaces_csv')

#+end_src
**** saving and loading data
***** pickle
pickle needs to be avoided because it can create dangerous files. [[https://docs.python.org/2/library/pickle.html][warning in doc link]]
prefer json over pickle (see after)
#+begin_src python :results output
import pickle
  
# Create a variable
myvar = [{'This': 'is', 'Example': 2}, 'of',
         'serialisation', ['using', 'pickle']]
  
# Open a file and use dump()
with open('file.pkl', 'wb') as file: #wb for write binary
    # A new file will be created
    pickle.dump(myvar, file)
#+end_src
***** json
****** lists
#+begin_src python :results output
#!/usr/bin/env python3
import json


liste = ['trc', 1, 3]

with open('mydata_list.json', 'w') as f:
    json.dump(liste, f)

with open('mydata_list.json', 'r') as f:
    loaded_list = json.load(f)

print(loaded_list)

print(np.array(loaded_numpy))
#+end_src
****** datetime

#+begin_src python :results output
import json

class DateTimeEncoder(json.JSONEncoder):
    def default(self, z):
        if isinstance(z, datetime.datetime):
            return (z.isoformat())
        else:
            return super().default(z)


my_dict = {'date': datetime.datetime.now()}

print(json.dumps(my_dict,cls=DateTimeEncoder))
#+end_src

****** arrays
******* the naive way
#+begin_src python :results output
#!/usr/bin/env python3
import json
import numpy as np

array_matrix = np.array([[1,3,3],
                        [0,2,2]])

with open('mydata_numpy.json', 'w') as f:
    # json doesn't handle arrays, we need to convert it first
    json.dump(array_matrix.tolist(), f)

with open('mydata_numpy.json', 'r') as f:
    # and convert it back to array
    loaded_matrix = np.array(json.load(f))
    
print(loaded_matrix)
#+end_src
******* the cool/extensive way
******** the encoder
********* encoder
[[https://pynative.com/python-serialize-numpy-ndarray-into-json/][source]]
you can also define your own custom encoder class thanks to
json.JSONEncoder:

create a file called json_encoder.py in your project

#+begin_src python :results output
import numpy as np
import json

class NumpyEncoder(json.JSONEncoder):
    """ Special json encoder for numpy types """
    def default(self, obj):
        if isinstance(obj, (np.int_, np.intc, np.intp, np.int8,
                            np.int16, np.int32, np.int64, np.uint8,
                            np.uint16, np.uint32, np.uint64)):
            return int(obj)
        elif isinstance(obj, (np.float_, np.float16, np.float32,
                              np.float64)):
            return float(obj)
        elif isinstance(obj, (np.ndarray,)):
            return obj.tolist()
        return json.JSONEncoder.default(self, obj)
#+end_src

********* another one, more simple
#+begin_src python :results output
import numpy as np
import json
from json import JSONEncoder

class NumpyArrayEncoder(JSONEncoder):
    def default(self, obj):
        if isinstance(obj, numpy.ndarray):
            return obj.tolist()
        return JSONEncoder.default(self, obj)
#+end_src
******** encoding and decoding a file
if you created the encoder in a file json_encoder.py
(cf last header to get the content of json_encoder.py)
#+begin_src python :results output
import json_encoder
import numpy as np

numpy_data = np.array([1,2])

# to write to a file:
with open("json_filename.json", "w") as write_file:
    json.dump(numpy_data,
              write_file,
              cls=json_encoder.NumpyEncoder)
    
# it also works with a dictionnary
numpy_dic = {"arrayOne": numpy_data, "arrayTwo": numpy_data*2}

with open("numpyData.json", "w") as write_file:
    json.dump(numpy_dic,
              write_file,
              cls=NumpyArrayEncoder)

# decoding a file
with open("numpyData.json", "r") as read_file:
    decoded_numpy_dic = json.load(read_file)
    finalNumpyArrayOne = numpy.asarray(decoded_numpy_dic["arrayOne"])

# tip: you can do something like
for key in decoded_numpy_dic.keys():
    if 'array' in key:
        decoded_numpy_dic[key] = np.asarray(decoded_numpy_dic[key])
    
#+end_src

#+RESULTS:

******** just like this
#+begin_src python :results output
import json
from json import JSONEncoder
import numpy

class NumpyArrayEncoder(JSONEncoder):
    def default(self, obj):
        if isinstance(obj, numpy.ndarray):
            return obj.tolist()
        return JSONEncoder.default(self, obj)

numpyArrayOne = numpy.array([[11, 22, 33], [44, 55, 66], [77, 88, 99]])

# Serialization
numpyData = {"array": numpyArrayOne}
encodedNumpyData = json.dumps(numpyData, cls=NumpyArrayEncoder)  # use dump() to write array into file
print("Printing JSON serialized NumPy array")
print(encodedNumpyData)

# Deserialization
print("Decode JSON serialized NumPy array")
decodedArrays = json.loads(encodedNumpyData)

finalNumpyArray = numpy.asarray(decodedArrays["array"])
print("NumPy Array")
print(finalNumpyArray)
#+end_src
*** Types and their methods
**** String
***** String formating
  #+begin_src python 
  # par exemple quand on importe une image:
  chemin = ...
  iphoto = ...
  img = scim.imread('{}{}.jpg'.format(chemin, iphoto))
  #+end_src

  #+begin_src python :results output
  '{:.2f} - '.format(100*ratio_pixels)
  #+end_src
  #RS# Vous trouverez de nombreux exemples/tuto format sur
  internet. Juste ici, `:` dit que l'on précise un format d'affichage,
  `.2` signifie que l'on veut une précision de 2 chiffres après la
  virgule, et `f` précise que nos valeurs doivent être interprétées
  comme des flottants.
***** regular expressions to split

#+begin_src python :results output
import re
l = r'truc|--styléaet:chouette'
print( re.split(r'a|\|--|:', l) ) 

#+end_src

#+RESULTS:
: ['truc', 'stylé', 'et', 'chouette']

***** Removing/stripping leading/first/last/some character
#+begin_src python :results output
l = '00testttt00000'
print(l.lstrip('0'))
print(l.rstrip('0'))
print(l.strip('0'))
#+end_src

#+RESULTS:
: testttt00000
: 00testttt
: testttt

***** Joining elements of a list of str
#+begin_src python :results output
liste = ["a", "b", "c"]
print("\n".join(liste))
#+end_src

#+RESULTS:
: a
: b
: c

**** List
***** Filtering
 example using filter builtin function:
 #+begin_src python :results output
 ext_variables = filter(lambda e: not(e.startswith("__")), ext_variables)
 #+end_src
***** Remove
remove an element from a list
#+begin_src python :results output
liste.remove(element)
#+end_src

***** getting the argument/index of an element
#+begin_src python :results output
liste = [1,2]
print( liste.index(1))
#+end_src

#+RESULTS:
: 0

**** Fonctions
 assert and multi affectation on return
 #+begin_src python :results output
 def f(x):
     assert x != 0,"x should not be equal to zero"
     return 1/x,x
 a,b = f(0)
 #+end_src

 #+RESULTS:

**** Classes
 Un exemple:
 #+begin_src python 
 class Narvalo:
     def __init__(self, nom, age):
         self.nom = nom
         self.age = age

     def get_nom(self):
         return self.nom

     def get_age(self):
         return self.age

     def add_age(self, n):
         self.age += n


 class Etudiant(Narvalo):
     def __init__(self, nom, age, ecole):
         super().__init__(nom, age)
         self.ecole = ecole

     def get_ecole(self):
         return self.ecole

     # On pourrait par exemple définir une autre fonction utilisant une fonction de la classe supérieure,
     # en écrivant super().fonction(....)


 if __name__ == '__main__':
     Mehdi = Narvalo('Mehdi', 23)

     print(Mehdi.get_age())
     print(Mehdi.get_nom())
     print('Je vais ajouter une année')
     Mehdi.add_age(1)
     print(Mehdi.get_age())

     Line = Etudiant('Line', 23, 'INSA')

     print('On a créé une classe étudiant, avec dedans {}, qui a {} ans et est à {}'.format(Line.get_nom(), Line.get_age(), Line.get_ecole()))

     if issubclassB(Etudiant, Narvalo):
         print("Oui Etudiant est une subclasse de Narvalo")
 #+end_src

**** numpy arrays
***** Masks
****** exemple 1
#+begin_src python :results output

#deux premières colonnes et éléments >= 0
Resultat=Resultat[Resultat[:,2] >= 0]

#A, B des tableaux numpy de même dimensions, v une valeur
A = B > v
Nb = np.count_nonzero(A)
#or : Nb = np.count_nonzero(B > v)
#sommer les valeurs plus grandes que v de B:
Sum = B[A].sum()

#+end_src

#+begin_src python :results output

data_L[data_L > 90] = 180 - data_L[data_L > 90]

#+end_src

****** exemple 2

numerical_data[:,2] is the uncertainty
numerical_data[:,2] is the measurement

here we troncate the results that have too much uncertainty (because
it bloated the plot with a huge errorbar, not because I am cheating)

#+begin_src python :results output
mask = numerical_data[:,2]/numerical_data[:,1] < 0.5
numerical_data_troncated = numerical_data[mask]
#+end_src

***** Sorting consistently
#+begin_src python :results output

idx = A.argsort()[::-1]   
A = A[idx]
B = B[:,idx]
#+end_src

***** Infos tableau
 #+begin_src python :results output
 n,p = tableau.shape
 #+end_src

***** Exemple tableau intensité
 J'ai un tableau numpy qui s'appelle img, et je veux compter le nombre
 de pixels au dessus d'une certaine valeur dans
 nombre_pixels_lumineux. Je veux aussi l'intensité totale de tous les
 pixels qui sont au dessus d'une certaine valeur.
 #+begin_src python :results output
 # Comptage des pixels lumineux
 bright_pixels = img > valeur_limite
 nombre_pixels_lumineux = np.count_nonzero(bright_pixels) # Or even: bright_pixels.sum()

 # Calcul des intensités cumulées
 intensite_pixels_allumes = img[bright_pixels].sum()
 intensite = img[img > 25].sum()
 #+end_src
***** Indexing
#+begin_src python :results output
A[0::2,0::2]=0 # in odd lines set odd elemets
A[1::2,1::2]=0 # in even lines set even elements
#+end_src
***** useful functions of numpy
****** np.unique
sorts an array and returns the sorted array without doublons
#+begin_src python :results output
np.unique
#+end_src
get the indices of an "array boolean expression"
#+begin_src python :results output
[row,column]=np.where(tri==i)
#+end_src
(tri is an array, i an integer)
gets the indices (rows columns) of elements of tri equal to i
****** testing float
https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_almost_equal.html
       np.almost equal or something sometimes
       
**** pile/"rope" structure
#+begin_src python :results output
from collections import deque
Q = deque([1, 3, 5])
print(Q.popleft())
print(Q.pop())
Q.append(8)
print(Q)
Q.appendleft(10)
print(Q)
#+end_src
**** pandas
[[https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html][10 min user guide]]
df is usually a dataframe
stopped writing at:
[[https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html#operations][link]]
***** creating data
****** classic series
#+begin_src python :results output
import numpy as np
import pandas as pd

s = pd.Series([1, 3, 5, np.nan, 6, 8])
print(s)
#+end_src

#+RESULTS:
: 0    1.0
: 1    3.0
: 2    5.0
: 3    NaN
: 4    6.0
: 5    8.0
: dtype: float64

****** date range
#+begin_src python :results output
import numpy as np
import pandas as pd

d = pd.date_range("20211201", periods=6, freq="D")
print(d)
#+end_src

#+RESULTS:
: DatetimeIndex(['2021-12-01', '2021-12-02', '2021-12-03', '2021-12-04',
:                '2021-12-05', '2021-12-06'],
:               dtype='datetime64[ns]', freq='D')

****** dataframe (abbreviated df)
******* with a numpy array
you can "tag" (name) the rows with "index", and the columns with
"columns"
#+begin_src python :results output
import numpy as np
import pandas as pd

dates = pd.date_range("20130101", periods=6)
df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list("ABCD"))
print(df)
#+end_src

#+RESULTS:
:                    A         B         C         D
: 2013-01-01  0.208522  0.860985  0.267739  0.193295
: 2013-01-02 -1.404824  1.352148  0.363108  0.527761
: 2013-01-03  1.314285 -0.668147 -1.235518 -0.147598
: 2013-01-04 -0.661288  2.069289  1.177938  0.229748
: 2013-01-05 -0.974901  1.062613  0.685958 -0.978787
: 2013-01-06 -1.679077 -1.182110  1.857067 -0.713573
******* with a dictionnary
if you have a dictionnary with data that is series like:
#+begin_src python :results output
d ={"A": 1.0,
    "B": pd.Timestamp("20130102"),
    "C": pd.Series(1, index=list(range(4)), dtype="float32"),
    "D": np.array([3] * 4, dtype="int32"),
    "E": pd.Categorical(["test", "train", "test", "train"]),
    "F": "foo"}
#+end_src
meaning that the values of a key are all the same type,

then you can create a dataframe with it, your *series (values of one
key)* will be *the columns*

#+begin_src python :results output
import numpy as np
import pandas as pd

df = pd.DataFrame({"A": 1.0,
                   "B": pd.Timestamp("20130102"),
                   "C": pd.Series(1, index=list(range(4)), dtype="float32"),
                   "D": np.array([3] * 4, dtype="int32"),
                   "E": pd.Categorical(["test", "train", "test", "train"]),
                   "F": "foo"})
print(df)
#+end_src

#+RESULTS:
:      A          B    C  D      E    F
: 0  1.0 2013-01-02  1.0  3   test  foo
: 1  1.0 2013-01-02  1.0  3  train  foo
: 2  1.0 2013-01-02  1.0  3   test  foo
: 3  1.0 2013-01-02  1.0  3  train  foo

******* adding a column to a df
Setting a new column automatically aligns the data by the indexes.
#+begin_src python :results output
import numpy as np
import pandas as pd
df = pd.DataFrame(np.random.randn(4, 3),
                   index=list('abcd'),
                   columns=list('ABC'))

print(df)

s1 = pd.Series([1,2,4,3],
               index=list('abdc'))
df['D'] = s1
print(df)
#+end_src

#+RESULTS:
#+begin_example
          A         B         C
a  0.193567  1.192956  0.511580
b  1.428451  0.291447 -2.245663
c  0.292541  0.660127  0.506712
d  0.670781 -0.421005 -1.396154
          A         B         C  D
a  0.193567  1.192956  0.511580  1
b  1.428451  0.291447 -2.245663  2
c  0.292541  0.660127  0.506712  3
d  0.670781 -0.421005 -1.396154  4
#+end_example

****** missing data (NaN)
non attribuated values:
#+begin_src python :results output
np.nan
#+end_src
***** checking dtypes
will show the types of the columns
#+begin_src python :results output
print(df.dtypes)
#+end_src
***** visualizing data
****** index and columns
#+begin_src python :results output
df.index
df.columns

# to see only the "A" column
df["A"]
#+end_src
****** head, tail
head, tail, slicing a df...
#+begin_src python :results output
df.head()
df.tail(3)
#+end_src
****** summary/overview
#+begin_src python :results output
# show a quick summary of your data
df.describe()
#+end_src
***** manipulating data
****** usual operations
******* matrix operations
#+begin_src python :results output
# you can have the transpose of a data frame
df.T
#+end_src
******* sorting
#+begin_src python :results output
# sort dataframe by an index
df.sort_index(axis=1, ascending=False)
# sort dataframe by a value
df.sort_values(by="B")

#+end_src
******* filtering/slicing
******** masks, slicing with boolean
********* with loc
(NA values in a boolean array propagate as False:)
#+begin_src python :results output
import numpy as np
import pandas as pd
df1 = pd.DataFrame(np.random.randn(4, 2),
                   index=list('abcd'),
                   columns=list('AB'))

print(df1)
print(df1.loc['a'] > 0)
print(df1.loc[:, df1.loc['a'] > 0])
#+end_src

#+RESULTS:
#+begin_example
          A         B
a -0.581268 -0.425033
b -0.081686 -0.970850
c  0.154261  0.068778
d  0.414434  0.087521
A    False
B    False
Name: a, dtype: bool
Empty DataFrame
Columns: []
Index: [a, b, c, d]
0.4187318141646289
#+end_example
********* more intuitive
#+begin_src python :results output
df[df["A"] > 0]
df[df > 0]
#+end_src
********* isin() select exact matches in a column
#+begin_src python :results output
import numpy as np
import pandas as pd
df = pd.DataFrame(np.random.randn(4, 3),
                   index=list('abcd'),
                   columns=list('ABC'))

df['D'] = ['one', 'two', 'one', 'four']
print(df)
print(df[df['D'].isin(['one', 'two'])])

#+end_src

#+RESULTS:
:           A         B         C     D
: a -0.999080 -2.150070  0.356084   one
: b  1.160267  0.821434  0.232759   two
: c -1.176986 -1.664059  0.234450   one
: d -2.102014  0.128647  1.666800  four
:           A         B         C    D
: a -0.999080 -2.150070  0.356084  one
: b  1.160267  0.821434  0.232759  two
: c -1.176986 -1.664059  0.234450  one

********* changing particular values
to change the positive values by multiplying them by -1
#+begin_src python :results output
df2[df2 > 0] = -df2
#+end_src
******** slicing
********* like numpy
#+begin_src python :results output
import pandas as pd
import numpy as np

dates = pd.date_range("20130101", periods=4)
df = pd.DataFrame(np.random.randn(4, 2), index=dates, columns=list("AB"))

print(df)
print("-----------")
print(df[0:1])
#+end_src

#+RESULTS:
:                    A         B
: 2013-01-01  0.147111  1.039859
: 2013-01-02 -0.054329  0.456417
: 2013-01-03  0.352620  0.124670
: 2013-01-04  0.874506 -0.254907
: -----------
:                    A         B
: 2013-01-01  0.147111  1.039859

********* with .loc
you can also use the index and columns, and kinda like numpy
*both endpoints* are *included*
#+begin_src python :results output
import numpy as np
import pandas as pd

df1 = pd.DataFrame(np.random.randn(6, 4),
                   index=list('abcdef'),
                   columns=list('ABCD'))
print(df1)
print(df1.loc[['a', 'd'], :])
print("only A")
print(df1.loc['d':, 'A'])
#+end_src

#+RESULTS:
#+begin_example
          A         B         C         D
a  0.537093 -0.102838 -0.434069 -0.021402
b  1.056246 -0.748348  0.392317  0.996767
c -0.451420  0.994168 -1.256889 -0.025011
d  0.778027 -1.447381  2.389844 -0.150592
e -0.182324  0.638212 -0.676576  0.639734
f -0.588683  0.605183  0.427892  1.274875
          A         B         C         D
a  0.537093 -0.102838 -0.434069 -0.021402
d  0.778027 -1.447381  2.389844 -0.150592
only A
d    0.778027
e   -0.182324
f   -0.588683
Name: A, dtype: float64
#+end_example

********* with .iloc
it's like numpy, using the position of passed integers
#+begin_src python :results output
# fourth row
df.iloc[3]
# 3-4 rows, 0-1 columns
df.iloc[3:5, 0:2]
# with list of int
df.iloc[[1, 2, 4], [0, 2]]
#+end_src
******** more complex slicing/filtering
:PROPERTIES:
:keywords: complex customized boolean mask pandas
:END:
[[https://pandas.pydata.org/docs/user_guide/indexing.html#boolean-indexing][boolean indexing guide page]]
List comprehensions and the map method of Series can also be used to
produce more complex criteria for boolean masks:
#+begin_src python :results output
import pandas as pd
import numpy as np
df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'three', 'two', 'one', 'six'],
                    'b': ['x', 'y', 'y', 'x', 'y', 'x', 'x'],
                    'c': np.random.randn(7)})



# only want 'two' or 'three'
criterion = df2['a'].map(lambda x: x.startswith('t'))

print(df2)
print('---------')
print(df2[criterion])
#+end_src

#+RESULTS:
#+begin_example
       a  b         c
0    one  x -0.279617
1    one  y -1.153427
2    two  y  0.548806
3  three  x -0.581544
4    two  y -1.197354
5    one  x -0.137980
6    six  x -1.632937
---------
       a  b         c
2    two  y  0.548806
3  three  x -0.581544
4    two  y -1.197354
#+end_example

******** groupby
good source:
https://appdividend.com/2020/06/02/pandas-dataframe-groupby-method-in-python/
********* groupby
it returns iterators: group name and group dataframe/series
#+begin_src python :results output
import pandas as pd

dataset = {
    'Name': ['Rohit', 'Arun', 'Sohit', 'Arun', 'Shubh'],
    'Roll no': ['01', '02', '03', '04', '05'],
    'maths': ['93', '63', '74', '94', '83'],
    'science': ['88', '55', '66', '94', '35'],
    'english': ['93', '74', '84', '92', '87']}

df = pd.DataFrame(dataset)
by_name = df.groupby(['Name'])

for Name, maths in by_name:
    print(f"First 2 entries for {Name!r}")
    print("------------------------")
    print(maths.head(2), end="\n\n")
#+end_src

#+RESULTS:
#+begin_example
First 2 entries for 'Arun'
------------------------
   Name Roll no maths science english
1  Arun      02    63      55      74
3  Arun      04    94      94      92

First 2 entries for 'Rohit'
------------------------
    Name Roll no maths science english
0  Rohit      01    93      88      93

First 2 entries for 'Shubh'
------------------------
    Name Roll no maths science english
4  Shubh      05    83      35      87

First 2 entries for 'Sohit'
------------------------
    Name Roll no maths science english
2  Sohit      03    74      66      84

#+end_example

********* getting the values of a group

******* statistics
******** mean
#+begin_src python :results output
df.mean()
#+end_src
****** managing nan
******* filtering rows with nan
to drop any row with a nan in it
#+begin_src python :results output
df1.dropna(how="any")
#+end_src
******* filling nan
#+begin_src python :results output
df1.fillna(value=5)
#+end_src
******* boolean mask nan
#+begin_src python :results output
pd.isna(df1)
#+end_src
****** managing columns/indexing
******* reindex
returns a copy of the dataframe
it's to change the ORDER
#+begin_src python :results output
index_list = list('abcd')
column_list = list('acdb')
df.reindex(index=index_list, columns=column_list)
#+end_src

to really change the index:
#+begin_src python :results output
df.index = list('ABCE')
# or
df.columns = list('ABCE')
#+end_src

****** copying a dataframe
#+begin_src python :results output
df.copy()
#+end_src
****** to numpy
it's expensive and creates a dtype = object array if you have
different data types in your df
#+begin_src python :results output
df.to_numpy()
#+end_src
****** getting scalars fast
you can do it with .loc or .iloc, but it's way faster for your
algorithm to do it with .at and .iat:

for instance
#+begin_src python :results output
df.iat[1, 1]
df.at['a','A'] = 0
#+end_src
*** Python version
#+begin_src python 
from platform import python_version
print(python_version())
#+end_src
ou:
#+begin_src python 
import sys
sys.version
#+end_src

pour faire un test:
#+begin_src python 
#sys.version_info
#assert sys.version_info >= (2, 5),"your version is less than 2.5"
#+end_src
*** Plot graph
https://scipy-lectures.org/intro/matplotlib/
https://towardsdatascience.com/an-introduction-to-making-scientific-publication-plots-with-python-ea19dfa7f51e
**** cheatsheet
***** simple subplot
#+begin_src python :results output
# sharex if you want them to share the same x axis
fig, axs = plt.subplots(2, sharex=True)

axs[0].plot(x, y,
            label=r'$\alpha$')
axs[0].set_title('Axis 0')
axs[0].grid(visible = True, linestyle = '--')

axs[1].plot(x, y, 'tab:orange')
axs[1].set_yscale('log')
axs[1].set_title('Axis 1')

# to put a legend for all of them
for ax in axs.flat:
    ax.set(xlabel='x-label', ylabel='y-label')

# Hide x labels and tick labels for top plots and y ticks for right plots.
for ax in axs.flat:
    ax.label_outer()

fig.savefig('path/plot.pdf')
#+end_src
***** 2x2 subplot
#+begin_src python :results output
# for a 2x2 plot:
fig, axs = plt.subplots(2,2, sharex=True)
axs[0,1].plot(...)
#+end_src
***** more designable subplots gridspec
this does something like:

#+begin_comment
._______.
._______.
._______. ._.
.       . . .
.       . . . 
.       . . .
._______. ._.
#+end_comment

#+begin_src python :results output
fig = plt.figure(figsize = (8, 8),
                 constrained_layout=True)
# this lets you divide your figure wiht a 5*5 grid,
# letting you customize the size of your axes/subplots in it
gs = fig.add_gridspec(5, 5)
# this subplot is:
# all lines but the first,
# all columns but the last.
ax_scatter = fig.add_subplot(gs[1:, :-1])
# this subplot is:
# first line,
# all columns but the last.
# you can also share an axis with another subplot with sharex/sharey
ax_xbin = fig.add_subplot(gs[0, :-1], sharex=ax_scatter)
# this subplot is:
# all lines but the first,
# last column
ax_ybin = fig.add_subplot(gs[1:, -1], sharey=ax_scatter)
ax_scatter.grid(visible = True, linestyle = 'dotted')
ax_xbin.grid(visible = True)
ax_ybin.grid(visible = True)
#+end_src
**** list of options for often used options for plot
**** latex in plots
it's with =r"I want write in $LaTeX$"= !
example:

#+begin_src python :results output
ax.set(ylabel=r"$\nu$ Coefficient de poisson")
#+end_src
*** Fonctions
**** inline functions
inline function
a function without def
#+begin_src python :results output
lambda e: not(e.startswith("__"))
#+end_src
**** mapping functions to lists
#+begin_src python :results output
items = [1,2,3,4,5]
def sqr(x): return x ** 2
list(map(sqr, items))
# or even
list(map((lambda x: x**2), items))
# this works too
list(map((lambda x,y: x**2-y**2), items,items))
#+end_src
**** vectorising functions
the output will always be an array
:tip: be careful, it gives the illusion of speed but it's loops!
#+begin_src python :results output
np.vectorize(function)
#+end_src
*** Exceptions handling
#+begin_src python :results output
# if not everyone has the fast lib
try:
    from fastlib import xyz as foo
except ImportError:
    from defaultlib import abc as foo
#+end_src
** Particular
*** image brightness (wallpaper)
#+begin_src python :results 
import cv2
import numpy as np

def compute_brightness(image):
    """return an array with the perceived brightness of each pixel from a
    numpy image
    """
    brightness  =  np.sqrt( 0.241*image[:,:,0] + 0.691*image[:,:,1] + 0.068*image[:,:,2])
    return brightness

def compute_light_level(image_path):
    max_score = np.sqrt( .241*255 + .691*255 + .068*255 )
    image = cv2.imread(image_path)
    brightness = compute_brightness(image)
    score = brightness.mean()
    level = score/max_score
    return level
#+end_src
*** Progress bar
#+begin_src python :results output
import sys
def progress_bar(count, total, status=''):
    bar_len = 30
    filled_len = int(round(bar_len * count / float(total)))

    percents = round(100.0 * count / float(total), 1)
    bar = '|' * filled_len + '-' * (bar_len - filled_len)

    sys.stdout.write('[%s] %s%s ...%s\r' % (bar, percents, '%', status))
    sys.stdout.flush()
#+end_src

for ...:
    progress_bar(i, max)

*** Slow print
#+begin_src python 
import sys
import time

def slowprint(s):
  for c in s + '\n':
    sys.stdout.write(c)
    sys.stdout.flush()
    time.sleep(1/20)

if __name__ == "__main__":
  slowprint("This is a test of slowprint")
#+end_src
*** bash
get bash output 
and run bash command
https://unix.stackexchange.com/questions/190495/how-to-execute-a-bash-command-in-a-python-script

#+begin_src python :results output
import subprocess

res = subprocess.check_output(["ls", "-l"])
for line in res.splitlines():
    print(line)
#+end_src
* pip and packages
** opencv

source:
https://forum.qt.io/topic/119109/using-pyqt5-with-opencv-python-cv2-causes-error-could-not-load-qt-platform-plugin-xcb-even-though-it-was-found/9

problem when showing an image, solution:
- uninstall opencv-python
- install opencv-python-headless
** pip
dont forget to install pip via your package manager...
** upgrade packages
upgrade python packages: 
write that in shell
[[https://www.studytonight.com/python-howtos/upgrade-all-packages-in-python-using-pip][source]]
#+begin_comment
pip3 list --outdated --format=freeze | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip3 install -U 
#+end_comment

* Other
** Physique courses
*** Computational statistical physics



 - defining a new array

 #+begin_src python :results output
 import numpy as np
 copied_array = 1.*your_array
 #+end_src

 - iterations in arrays, you can also do this:

 #+begin_src python :results output
 new_vx[i] *= -1
 #+end_src

** Numerical project course (unchecked)
*** Functional/Object oriented programming
**** exceptions handling
#+begin_src python :results output
# if not everyone has the fast lib
try:
    from fastlib import xyz as foo
except ImportError:
    from defaultlib import abc as foo
#+end_src

**** classes
***** defining a class
 convention:
 capital letter for classes, and nothing else
 #+begin_src python :results output :session
 class Planet():
     def __init__(self):
         self.x = 3
         self.y = 4
     def getx(self):
         return self.x

 class Person():
     def __init__(self, name, age):
         self.name = name
         self.age = age

 earth = Planet()
 print(earth.getx())
 # you can also: but it's not a good habit (explanation after)
 print(earth.x)
 #+end_src

 #+RESULTS:
 : 3
 : 3

 generally, you want to have functions giving the client (the dude
 printing print(earth.getx())) the information he wants, and not having
 the client fetch directly in your variables

***** property decorator
#+begin_src python :results output
class Planet():
    def __init__(self):
        self.x = 3
        self.y = 4
    @property
    def getx(self):
        return self.x
#+end_src
***** subclass
#+begin_src python :results output :session
class Planet():
    def __init__(self):
        self.x = 3
        self.y = 4
    def getx(self):
        return self.x

class Earth(Planet):
    def __init__(self):
        Planet.__init__(self)
        self.x = 3
        self.y = 4
    def getx(self):
        return self.x
#+end_src

***** class operators overloading
****** documentation
documentation: [[https://docs.python.org/3/reference/datamodel.html#object.__getitem__][python website]]
****** example with == + * / ...
example:
str len in ect... make them work for your class
print(object_of_your_class)
#+begin_src python :results output
class Planet():
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
    def getx(self):
        return self.x
    def __str__(self):
        return f"x:{self.x}\ny:{self.y}"
    # Planet1 == Planet2
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    # Planet1 + Planet2
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    # Planet1 - Planet2
    def __sub__(self, other):
        return Point(self.x + other.x, self.y + other.y)
    # Planet1 * Planet2
    def __mul__(self, other):
        return self.x * other.x + self.y * other.y
    # Planet1 > Planet2
    def __gt__(self, other):  # greater than
        return self.length() > other.length()
    # Planet1 >= Planet2
    def __ge__(self, other):  # greater than or equal to
        return self.length() >= other.length()
    # Planet1 < Planet2        
    def __lt__(self, other):  # less than
        return self.length() < other.length()
    # Planet1 <= Planet2
    def __le__(self, other):  # less than or equal to
        return self.length() <= other.length()
    
my_planet = Planet()
print(my_planet)
#+end_src

#+RESULTS:
: x:3
: y:4

****** example with Object[key]
[[https://stackoverflow.com/questions/33881694/overloading-the-operator-in-python-class-to-refer-to-a-numpy-array-data-membe][source]]
#+begin_src python :results output
import numpy as np

class MyArray():
    def __init__(self):
        self.data = np.zeros(10)

    def __getitem__(self, key):
        return self.data[key]

    def __setitem__(self, key, value):
        self.data[key] = value

    def __repr__(self):
        return 'MyArray({})'.format(self.data)


a = MyArray()

print(a[9])
print(a[1:5])
a[:] = np.arange(10)
print(a)
#+end_src

#+RESULTS:
: 0.0
: [0. 0. 0. 0.]
: MyArray([0. 1. 2. 3. 4. 5. 6. 7. 8. 9.])

*** conventions in programming
if you put _ in the beginning of a variable, it's like saying "please
don't change this name or it will break the code"

all caps: constant of the code

*** pep8
software you can install via pip:
- pycodestyle pep 8 (for the code)
- pydocstyle pep 257 (for the documentation)
- black (to reformat to pep8)

make your code readable by shortening your program, by calling
functions that are understandable

*** sphinx to manage documentation
- comments and documentation explain intentions, not exactly what the code does
  (if its too obvious)
- deviation from standard
- unexpected choices of implementation

renaming variables to have things
usually, people write documentation like a command: do this, return this...
dont describe it like 
this function does... and... ect

#+begin_src python :results output
def add(x,y):
    """Return sum."""
    return x+y

def add(x,y):
    """Return sum.

    keywords arguments:
    x the first
    y the secnod

    """
    return x+y
#+end_src

write it for everything!

*** unit testers
**** ideas
- fix bugs + make sure they are not reproduced
- helps with refactoring
- kinda like a documentation, but it is compiled/interpreted

the idea is to write another code that tests your code

UT frameworks:
- python: pytest, nose, doctest, unittest
- c++: catch, google test, boost.test, cppunit,

these frameworks can create Moc objects: commonly used in OO code
these objects can be difficult things to have irl (like an error, or
changing the clock of your computer...)

**** examples
#+begin_src python :results output
import pytest
@pytest.mark.parametrize("number, answer", [
    (1, 1),
    (2, 2),
    (3, 6),
    (4, 24),
    (10, 3628800),
])

# dont forget to define factorial
def test_int_factorials(number, answer):
    assert(factorial(number) == answer)

def test_another_func(number, answer):
    assert(another_func(1) == 2)        
#+end_src

**** test driven development
when writing code, you can begin to write a lot of tests if you
already know how your code should behave/what is the goal of your
code, and run the tests each time you modify something

if you find a bug, write a test so that you make sure you track it

*** argparse
**** simple stuff
10/13/2021
you can have a list of arguments sent from the terminal!

if you have a file script.py in a directory:
#+begin_src python :results output
import sys
print(sys.argv)
#+end_src

then writing
#+begin_src bash
python script.py arg1 arg2 lol
#+end_src
will return
#+begin_src 
["script.py", "arg1", "arg2", "lol"]
#+end_src

**** argparse
use argparse library if you want to do that kind of stuff! NEVER do it by yourself

*** exception handling

we get errors all the time, usually we can see them with error
outputs. But sometimes, it's difficult to see some of them...
example: a script which cannot locate a file

**** first example
#+begin_src python
number = input("input number")
try:
    k = 5//int(number)
    print(k)
except:
    print("Cannot divide by zero")

#+end_src
**** filtering errors
#+begin_src python
# you can also filter by errors
    number = input("input number")
try:
    k = 5//int(number)
    print(k)
except ZeroDivisonError:
    print("Cannot divide by zero")

#+end_src

**** other options (else/finally)
#+begin_src python
    
# you can also filter by errors
    number = input("input number")
try:
    k = 5//int(number)
    print(k)
except ZeroDivisonError:
    print("Cannot divide by zero")
else:
    # executes if everything works perfectly
    print('it succeeded')
finally:
    # executes no matter what happens
    print('end')

#+end_src
**** printing errors as you want
#+begin_src python
    number = input("input number")
try:
    k = 5//int(number)
    print(k)
except ZeroDivisonError:
    print("Cannot divide by zero")
# you can even print each Exception you have:
except Exception as e:
    print("print {}".format(e))
#+end_src

**** examples
example: adding things to a list, try for each item
if exception
print " i can't print this item" item

*** file handling
**** problem
if you leave a file opened, it can slow down your computer or cause problems
**** solution
don't
#+begin_src python :results output
f = open('file','r')
#+end_src

do :
#+begin_src python :results output
with open('file', 'r') as file:
#+end_src
so that the file is properly closed when you finish your stuff.
*** packaging
**** general knowledge

pip uses PyPI
npm is like PyPI but for java
**** how to share our codes

if you want to share:
put your .py file in a src file

#+begin_src python :results output


from setuptools import setup

setup(
    name = "mypyfile", # name of package to put after pip install
    version = "0.0.1", #0.0.x generally means it's unstable
    description = "descrip",
    #CF SLIDES
#+end_src

**** before uploading

don't forget to gitignore things and put classifiers so that people
can find your package easily

plus, you need to put documentation!!

**** testing

You NEED tests, and put them as "extras" (check slides)

to publish, you also need to put your email, phone number, and git
repo so that people can contact you

you have "check manifest" thing to help you complete everything (check
slide just before "Publish!"

there is also "twine" to publish stuff

**** there is also some things helping you

cookiecutter
you just need to answer a bunch of questions and it will help you to
setup your package

*** license

It depends on your project. But it's necessary to ask yourself some
questions for your code:

do I want it to be

by default:
exclusive copyright ! Nobody can use it, copy it, distribute,
modify...

if you put things on github: depends of terms of service

if you find code without license : don't use the software! find
alternatives
on github: open an issue requesting a license

choosealicense.com
*** parallel computing

there are software to do that... don't learn everything from scratch

learning to do it from 0 to something perfect: ~6 month if very lucky
and with an expert

for instance
"dask" check the tutorial it's super good!!!
"RAPIDS"

numerical recipes book

two possible things to try maybe?
f2py
or scython (but poor doc)
if there are no way to parrallelize your program!!

openMP handbook: well written

ali citation
- expert
- good teacher
- wants to teach
- can teach

also: if you want to make your code faster, USE TESTS!!!!!!!!!!! You
might create errors and it would be very easy to find them with tests

one time it took Ali 2 months to solve a problem like this...

Binder: useful to test things

** problèmes
*** liste qui se remplit de la même val
 #+begin_src python :results output
 #!/usr/bin/env python3
 import numpy as np
 import matplotlib.pyplot as plt

 # definition de la forme de la matrice utilisée
 def matrix_A(a):
     return np.array([[a,0,a],
                      [0,a,-2],
                      [a,1,8]])

 # definition des valeurs parcourues pour la matrice
 a = -12
 b = 12
 n_value = 20
 value_list = np.linspace(a, b, n_value)

 # génération de l'exemple
 valeurs_propres = np.zeros((n_value,3))
 vecteurs_propres = []
 for i in range(n_value):
     e = value_list[i]
     A = matrix_A(e)
     val_propre, vect_propre = np.linalg.eig(A)
     valeurs_propres[i,:] = val_propre

 # plot des valeurs propres de l'exemple
 fig = plt.figure()
 plt.plot(value_list, valeurs_propres[:,0])
 plt.plot(value_list, valeurs_propres[:,1])
 plt.plot(value_list, valeurs_propres[:,2])
 plt.savefig('testfig.pdf')

 valeurs_propres_ordonnees = np.zeros(np.shape(valeurs_propres))

 def reorder_array(M, x_values):
     """ 
     returns a reordered version of lists in M 
     lists are taken as columns
     """
     n_rows, n_columns = np.shape(M)
     new_M = 1.*M
    
     order = [list(range(n_columns))]
     for i in range(2, n_rows):
         print('iteration: {}\n{}\n'.format(i,order))
         last_step = x_values[i-1] - x_values[i-2]
         next_step = x_values[i] - x_values[i-1]

         derivative = (new_M[i-1,:] - new_M[i-2,:]) / last_step
         expected_value = new_M[i-1, :] + derivative * next_step

         expectation_error = np.abs(new_M[i, :] - expected_value)
         mean_error = np.mean(expectation_error)

         # :lkr:/ this sucks, :todo: later, make it proportional to
         # values of the table
         print('last ',order[-1])
         if mean_error > 2:
 #            print('{}\n'.format(mean_error))
 #            print('max found for i = {}\nx={}'.format(i, x_values[i]))
             sorted_errors = np.sort(expectation_error)
             max1 = sorted_errors[-1]
             max2 = sorted_errors[-2]
             arg_col1 = np.where(expectation_error == max1)[0][0]
             if max1 == max2:
                 arg_col2 = np.where(expectation_error == max2)[0][1]
             else:
                 arg_col2 = np.where(expectation_error == max2)[0][0]
 #            print('errors:\n{}\nargs computed:\n{}{}'.format(expectation_error, arg_col1, arg_col2))
             new_M[i:, [arg_col1, arg_col2]] = new_M[i:, [arg_col2, arg_col1]]
             new_order = order[-1]
             swapping_values = new_order[arg_col2], new_order[arg_col1]
             new_order[arg_col1], new_order[arg_col2] = swapping_values
             order.append(new_order)
         else: 
             order.append(order[-1])
     return np.array(order)

 errors = reorder_array(valeurs_propres, value_list)

 idx = valeurs_propres.argsort()[::-1]   

 print('output: \n{}'.format(order))

 fig = plt.figure()
 plt.plot(value_list, valeurs_propres[:, 0], label='val_1')
 plt.plot(value_list, valeurs_propres[:, 1])
 plt.plot(value_list, valeurs_propres[:, 2])
 plt.legend()
 plt.savefig('testfig_errors.pdf')


 # masks
 # data_L[data_L > 90] = 180 - data_L[data_L > 90]
 # # on réordonne tout en fonction de la valeur des valeurs propres
 # idx = Leig.argsort()[::-1]   
 # Leig = Leig[idx]
 # Osci = Osci[:,idx]

 #+end_src

 liste chelou, .copy(), mais pq? :todo:
 réglé en remplacant 
             new_order = order[-1]
 par 
             new_order = order[-1].copy()

*** imaginaires
 :tip: ne pas utiliser i*() mais ()*1j
** Souvenir rigolo
 #+begin_src python :results output
 #RS#            fichier.write("PARAMETRE : valeur_limite = ")
 #RS#            fichier.write(str(valeur_limite)+'\n') #RS# Tes valeurs méritent un affichage digne de ce nom avec un format ! Si tu n'es pas familier encore avec cette méthode, découvre sa puissance (de toute façon, ça fait partie des trucs qu'on considère connus pour l'examen) :
             fichier.write('PARAMETRE : valeur_limite = {}\n'.format(valeur_limite))
             ##
                 chemin = 'test'#'C:\\Users\\publi\\Desktop\\Cours ENS\\Rapport de TP\\O4\\Photos portable\\sans fer\\' #RS# Excellente initiative !
 #RS#                img = scim.imread(chemin+str(iphoto)+'.jpg', flatten=True) #RS# Ici aussi, un format s'impose !
                 img = scim.imread('{}{}.jpg'.format(chemin, iphoto), flatten=True)
                 ##
                 #RS# Je commente le bout de code ci-contre car je le renplace par un équivalent qui utilise toute l'incroyable puissance des tableaux Numpy !
 #                #Création des conteurs et des variables
 #                n,p = img.shape #RS# Oui !
 #                nombre_pixels_lumineux = 0
 #                intensite_pixels_allumes = 0
 #                intensite = 0
 #            
 #                #On analyse chaque pixel
 #                for i in range(n):
 #                    for j in range(p):
 #                        c = img[i][j] #RS# Ou là là, surtout pas, malheureux ! Où est donc passée la sensationnelle puissance des tableaux Numpy ? Ce code doit être particulièrement lent... Accroche-toi bien à ton siège, car avec le code que je m'en vais te proposer, ça va décoiffer !
 #                        
 #                        if c > valeur_limite:
 #                            nombre_pixels_lumineux +=1 #RS# Attention aux espaces, PEP8 recommende : nombre_pixels_lumineux += 1
 #                            intensite_pixels_allumes+=c
 #                        if c > 25: #car sinon on prend en compte tout le fond noir, qui n'a pas une intensité nulle. Donc le ratio sera trop petit vu le nombre de pixels avec une une intensité non nulle #RS# Heu... Je dois avouer que je suis un peu perdu ici... Y aurait-il 3 classes de pixels : fond noir, éteins, allumés ?
 #                            intensite += c
 #                
 #                #Calcul des ratios
 #                ratio_pixels = nombre_pixels_lumineux/img.size
 #                ratio_intensite = intensite_pixels_allumes/intensite
                
                 #RS# Vous l'attendez tous, le voici, le voilà, l'incroyable, le sensationnel, le magnifique... bout de code qui fait tout pareil, mais en formidablement plus rapide et résolument plus pythonique :
                
                 # Comptage des pixels lumineux
                 bright_pixels = img > valeur_limite
                 nombre_pixels_lumineux = np.count_nonzero(bright_pixels) # Or even: bright_pixels.sum()
                
                 # Calcul des intensités cumulées
                 intensite_pixels_allumes = img[bright_pixels].sum()
                 intensite = img[img > 25].sum()
                
                 #RS# Tout simplement ! Toute la quintessence des tableaux Numpy se retrouve ici, dans ce patchwork exquis de fonctionnalités Numpy avancées, en parfaite harmonie ! (mais qui sont quand même considérés comme connus pour l'examen... ^^)
                 ##
                 print(valeur_limite," et photo: ",iphoto)
 #                fichier.write("photo ")
 #                fichier.write(str(iphoto)+'\n')
 #                fichier.write(str(nombre_pixels_lumineux)+'\n')
 #                fichier.write(str(img.size)+'\n')
 #                fichier.write(str(round(100*ratio_pixels,2))+' %'+'\n')
 #                fichier.write(str(intensite_pixels_allumes)+'\n')
 #                fichier.write(str(intensite)+'\n')
 #                fichier.write(str(round(100*ratio_intensite,2))+' %'+'\n')
 #                fichier.write('\n') #RS# Avec un petit coup de format, ça devient :
                 fichier.write('photo {}\n'.format(iphoto))
                 fichier.write('{}\n'.format(nombre_pixels_lumineux))
                 fichier.write('{}\n'.format(img.size))
                 fichier.write('{:.2f} %\n'.format(100*ratio_pixels)) #RS# Vous trouverez de nombreux exemples/tuto format sur internet. Juste ici, `:` dit que l'on précise un format d'affichage, `.2` signifie que l'on veut une précision de 2 chiffres après la virgule, et `f` précise que nos valeurs doivent être interprétées comme des flottants.
                 ##
 #+end_src
